"""
Strategy Engine Module

This module handles strategy operations for the Evolve Trading Platform:
- Strategy generation and selection
- Signal generation and validation
- Strategy optimization and tuning
- Performance evaluation and metrics
"""

import pandas as pd
import numpy as np
import logging
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class StrategyType(Enum):
    """Available strategy types."""
    RSI = "rsi"
    MACD = "macd"
    BOLLINGER = "bollinger"
    SMA = "sma"
    EMA = "ema"
    CUSTOM = "custom"
    HYBRID = "hybrid"

class RiskLevel(Enum):
    """Risk levels for strategies."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CONSERVATIVE = "conservative"
    AGGRESSIVE = "aggressive"

@dataclass
class StrategySignal:
    """Trading signal generated by a strategy."""
    timestamp: datetime
    signal_type: str  # 'buy', 'sell', 'hold'
    confidence: float
    price: float
    strategy_name: str
    parameters: Dict[str, Any]
    reasoning: str

@dataclass
class StrategyResult:
    """Result of a strategy operation."""
    strategy_type: StrategyType
    signals: List[StrategySignal]
    performance_metrics: Dict[str, float]
    risk_metrics: Dict[str, float]
    parameters: Dict[str, Any]
    processing_time: float
    timestamp: datetime

class StrategyEngine:
    """Handles strategy operations and signal generation."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the strategy engine.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        self.strategies = {}
        
        # Initialize available strategies
        self._initialize_strategies()
    
    def _initialize_strategies(self):
        """Initialize available trading strategies."""
        try:
            # Import strategy classes
            from trading.strategies.rsi_strategy import RSIStrategy
            from trading.strategies.macd_strategy import MACDStrategy
            from trading.strategies.bollinger_strategy import BollingerStrategy
            from trading.strategies.sma_strategy import SMAStrategy
            
            # Initialize strategy instances
            self.strategies[StrategyType.RSI] = RSIStrategy()
            self.strategies[StrategyType.MACD] = MACDStrategy()
            self.strategies[StrategyType.BOLLINGER] = BollingerStrategy()
            self.strategies[StrategyType.SMA] = SMAStrategy()
            
            self.logger.info(f"Initialized {len(self.strategies)} trading strategies")
            
        except ImportError as e:
            self.logger.warning(f"Some strategies not available: {e}")
    
    def generate_strategy(self, data: pd.DataFrame, strategy_type: StrategyType,
                         risk_level: RiskLevel, **parameters) -> StrategyResult:
        """
        Generate trading signals using a specific strategy.
        
        Args:
            data: Historical price data
            strategy_type: Type of strategy to use
            risk_level: Risk level for the strategy
            **parameters: Strategy-specific parameters
            
        Returns:
            StrategyResult: Strategy result with signals
        """
        start_time = datetime.now()
        
        try:
            if strategy_type not in self.strategies:
                raise ValueError(f"Strategy type {strategy_type} not available")
            
            strategy = self.strategies[strategy_type]
            
            # Prepare data for strategy
            prepared_data = self._prepare_data(data, strategy_type)
            
            # Adjust parameters based on risk level
            adjusted_parameters = self._adjust_parameters_for_risk(parameters, risk_level, strategy_type)
            
            # Generate signals
            signals = strategy.generate_signals(prepared_data, **adjusted_parameters)
            
            # Calculate performance metrics
            performance_metrics = self._calculate_performance_metrics(signals, data)
            
            # Calculate risk metrics
            risk_metrics = self._calculate_risk_metrics(signals, data, risk_level)
            
            processing_time = (datetime.now() - start_time).total_seconds()
            
            result = StrategyResult(
                strategy_type=strategy_type,
                signals=signals,
                performance_metrics=performance_metrics,
                risk_metrics=risk_metrics,
                parameters=adjusted_parameters,
                processing_time=processing_time,
                timestamp=datetime.now()
            )
            
            self.logger.info(f"Generated strategy using {strategy_type.value}: {len(signals)} signals")
            return result
            
        except Exception as e:
            self.logger.error(f"Error generating strategy with {strategy_type.value}: {e}")
            raise
    
    def generate_hybrid_strategy(self, data: pd.DataFrame, strategies: List[StrategyType],
                               weights: Optional[Dict[str, float]] = None,
                               risk_level: RiskLevel = RiskLevel.MEDIUM) -> StrategyResult:
        """
        Generate a hybrid strategy combining multiple strategies.
        
        Args:
            data: Historical price data
            strategies: List of strategies to combine
            weights: Optional weights for each strategy
            risk_level: Risk level for the hybrid strategy
            
        Returns:
            StrategyResult: Hybrid strategy result
        """
        start_time = datetime.now()
        
        if weights is None:
            weights = {strategy.value: 1.0 / len(strategies) for strategy in strategies}
        
        individual_results = {}
        
        # Generate individual strategies
        for strategy_type in strategies:
            try:
                result = self.generate_strategy(data, strategy_type, risk_level)
                individual_results[strategy_type.value] = result
            except Exception as e:
                self.logger.warning(f"Failed to generate strategy with {strategy_type.value}: {e}")
        
        if not individual_results:
            raise ValueError("No successful individual strategies generated")
        
        # Combine signals
        combined_signals = self._combine_strategy_signals(individual_results, weights)
        
        # Calculate combined metrics
        performance_metrics = self._calculate_combined_performance(individual_results, weights)
        risk_metrics = self._calculate_combined_risk(individual_results, weights)
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        result = StrategyResult(
            strategy_type=StrategyType.HYBRID,
            signals=combined_signals,
            performance_metrics=performance_metrics,
            risk_metrics=risk_metrics,
            parameters={'strategies': [s.value for s in strategies], 'weights': weights},
            processing_time=processing_time,
            timestamp=datetime.now()
        )
        
        self.logger.info(f"Generated hybrid strategy using {len(individual_results)} strategies")
        return result
    
    def _prepare_data(self, data: pd.DataFrame, strategy_type: StrategyType) -> pd.DataFrame:
        """
        Prepare data for a specific strategy.
        
        Args:
            data: Raw data
            strategy_type: Type of strategy
            
        Returns:
            DataFrame: Prepared data
        """
        # Basic data preparation
        prepared_data = data.copy()
        
        # Ensure we have required columns
        required_columns = ['timestamp', 'Open', 'High', 'Low', 'Close', 'Volume']
        for col in required_columns:
            if col not in prepared_data.columns:
                raise ValueError(f"Required column '{col}' not found in data")
        
        # Sort by timestamp
        prepared_data = prepared_data.sort_values('timestamp').reset_index(drop=True)
        
        # Remove any NaN values
        prepared_data = prepared_data.dropna()
        
        # Add technical indicators
        prepared_data = self._add_technical_indicators(prepared_data)
        
        return prepared_data
    
    def _add_technical_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Add technical indicators to the data.
        
        Args:
            data: Price data
            
        Returns:
            DataFrame: Data with technical indicators
        """
        # Moving averages
        data['SMA_20'] = data['Close'].rolling(window=20).mean()
        data['SMA_50'] = data['Close'].rolling(window=50).mean()
        data['EMA_12'] = data['Close'].ewm(span=12).mean()
        data['EMA_26'] = data['Close'].ewm(span=26).mean()
        
        # RSI
        delta = data['Close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        data['RSI'] = 100 - (100 / (1 + rs))
        
        # MACD
        data['MACD'] = data['EMA_12'] - data['EMA_26']
        data['MACD_Signal'] = data['MACD'].ewm(span=9).mean()
        data['MACD_Histogram'] = data['MACD'] - data['MACD_Signal']
        
        # Bollinger Bands
        data['BB_Middle'] = data['Close'].rolling(window=20).mean()
        bb_std = data['Close'].rolling(window=20).std()
        data['BB_Upper'] = data['BB_Middle'] + (bb_std * 2)
        data['BB_Lower'] = data['BB_Middle'] - (bb_std * 2)
        data['BB_Width'] = (data['BB_Upper'] - data['BB_Lower']) / data['BB_Middle']
        
        # Price changes
        data['Price_Change'] = data['Close'].pct_change()
        data['Price_Change_5'] = data['Close'].pct_change(periods=5)
        
        # Volume indicators
        data['Volume_SMA'] = data['Volume'].rolling(window=20).mean()
        data['Volume_Ratio'] = data['Volume'] / data['Volume_SMA']
        
        return data
    
    def _adjust_parameters_for_risk(self, parameters: Dict[str, Any], 
                                  risk_level: RiskLevel, 
                                  strategy_type: StrategyType) -> Dict[str, Any]:
        """
        Adjust strategy parameters based on risk level.
        
        Args:
            parameters: Original parameters
            risk_level: Risk level
            strategy_type: Strategy type
            
        Returns:
            Dict: Adjusted parameters
        """
        adjusted_params = parameters.copy()
        
        # Risk level multipliers
        risk_multipliers = {
            RiskLevel.CONSERVATIVE: 0.5,
            RiskLevel.LOW: 0.7,
            RiskLevel.MEDIUM: 1.0,
            RiskLevel.HIGH: 1.3,
            RiskLevel.AGGRESSIVE: 1.5
        }
        
        multiplier = risk_multipliers.get(risk_level, 1.0)
        
        # Adjust parameters based on strategy type
        if strategy_type == StrategyType.RSI:
            # Adjust RSI thresholds
            if 'oversold_threshold' in adjusted_params:
                adjusted_params['oversold_threshold'] = max(20, adjusted_params['oversold_threshold'] * multiplier)
            if 'overbought_threshold' in adjusted_params:
                adjusted_params['overbought_threshold'] = min(80, adjusted_params['overbought_threshold'] * multiplier)
        
        elif strategy_type == StrategyType.MACD:
            # Adjust MACD sensitivity
            if 'signal_period' in adjusted_params:
                adjusted_params['signal_period'] = max(5, int(adjusted_params['signal_period'] / multiplier))
        
        elif strategy_type == StrategyType.BOLLINGER:
            # Adjust Bollinger Band sensitivity
            if 'std_dev' in adjusted_params:
                adjusted_params['std_dev'] = max(1.5, adjusted_params['std_dev'] * multiplier)
        
        return adjusted_params
    
    def _calculate_performance_metrics(self, signals: List[StrategySignal], 
                                     data: pd.DataFrame) -> Dict[str, float]:
        """
        Calculate performance metrics for strategy signals.
        
        Args:
            signals: Trading signals
            data: Historical data
            
        Returns:
            Dict: Performance metrics
        """
        if not signals:
            return {}
        
        # Calculate returns from signals
        returns = []
        for i, signal in enumerate(signals):
            if i < len(signals) - 1:
                next_signal = signals[i + 1]
                if signal.signal_type == 'buy' and next_signal.signal_type == 'sell':
                    return_val = (next_signal.price - signal.price) / signal.price
                    returns.append(return_val)
        
        if not returns:
            return {
                'total_signals': len(signals),
                'win_rate': 0.0,
                'avg_return': 0.0,
                'total_return': 0.0
            }
        
        # Calculate metrics
        winning_trades = [r for r in returns if r > 0]
        losing_trades = [r for r in returns if r <= 0]
        
        metrics = {
            'total_signals': len(signals),
            'total_trades': len(returns),
            'winning_trades': len(winning_trades),
            'losing_trades': len(losing_trades),
            'win_rate': len(winning_trades) / len(returns) if returns else 0.0,
            'avg_return': np.mean(returns),
            'total_return': np.sum(returns),
            'avg_win': np.mean(winning_trades) if winning_trades else 0.0,
            'avg_loss': np.mean(losing_trades) if losing_trades else 0.0,
            'profit_factor': abs(np.sum(winning_trades) / np.sum(losing_trades)) if losing_trades else float('inf')
        }
        
        return metrics
    
    def _calculate_risk_metrics(self, signals: List[StrategySignal], 
                              data: pd.DataFrame, 
                              risk_level: RiskLevel) -> Dict[str, float]:
        """
        Calculate risk metrics for strategy signals.
        
        Args:
            signals: Trading signals
            data: Historical data
            risk_level: Risk level
            
        Returns:
            Dict: Risk metrics
        """
        if not signals:
            return {}
        
        # Calculate returns from signals
        returns = []
        for i, signal in enumerate(signals):
            if i < len(signals) - 1:
                next_signal = signals[i + 1]
                if signal.signal_type == 'buy' and next_signal.signal_type == 'sell':
                    return_val = (next_signal.price - signal.price) / signal.price
                    returns.append(return_val)
        
        if not returns:
            return {
                'volatility': 0.0,
                'max_drawdown': 0.0,
                'sharpe_ratio': 0.0,
                'var_95': 0.0
            }
        
        # Calculate risk metrics
        volatility = np.std(returns)
        cumulative_returns = np.cumsum(returns)
        running_max = np.maximum.accumulate(cumulative_returns)
        drawdowns = running_max - cumulative_returns
        max_drawdown = np.max(drawdowns) if len(drawdowns) > 0 else 0.0
        
        # Sharpe ratio (assuming risk-free rate of 0)
        sharpe_ratio = np.mean(returns) / volatility if volatility > 0 else 0.0
        
        # Value at Risk (95%)
        var_95 = np.percentile(returns, 5) if len(returns) > 0 else 0.0
        
        risk_metrics = {
            'volatility': volatility,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'var_95': var_95,
            'avg_trade_duration': len(signals) / max(1, len(returns)),
            'risk_level': risk_level.value
        }
        
        return risk_metrics
    
    def _combine_strategy_signals(self, individual_results: Dict[str, StrategyResult], 
                                weights: Dict[str, float]) -> List[StrategySignal]:
        """
        Combine signals from multiple strategies.
        
        Args:
            individual_results: Individual strategy results
            weights: Strategy weights
            
        Returns:
            List[StrategySignal]: Combined signals
        """
        if not individual_results:
            return []
        
        # Get all unique timestamps
        all_timestamps = set()
        for result in individual_results.values():
            for signal in result.signals:
                all_timestamps.add(signal.timestamp)
        
        all_timestamps = sorted(list(all_timestamps))
        
        combined_signals = []
        
        for timestamp in all_timestamps:
            # Collect signals for this timestamp
            timestamp_signals = []
            for strategy_name, result in individual_results.items():
                for signal in result.signals:
                    if signal.timestamp == timestamp:
                        timestamp_signals.append((strategy_name, signal))
            
            if timestamp_signals:
                # Combine signals using weighted voting
                combined_signal = self._combine_timestamp_signals(timestamp_signals, weights)
                combined_signals.append(combined_signal)
        
        return combined_signals
    
    def _combine_timestamp_signals(self, timestamp_signals: List[Tuple[str, StrategySignal]], 
                                 weights: Dict[str, float]) -> StrategySignal:
        """
        Combine signals for a specific timestamp.
        
        Args:
            timestamp_signals: Signals for the timestamp
            weights: Strategy weights
            
        Returns:
            StrategySignal: Combined signal
        """
        # Calculate weighted scores for each signal type
        buy_score = 0.0
        sell_score = 0.0
        hold_score = 0.0
        
        total_confidence = 0.0
        avg_price = 0.0
        total_weight = 0.0
        
        for strategy_name, signal in timestamp_signals:
            weight = weights.get(strategy_name, 1.0 / len(timestamp_signals))
            confidence = signal.confidence
            
            if signal.signal_type == 'buy':
                buy_score += weight * confidence
            elif signal.signal_type == 'sell':
                sell_score += weight * confidence
            else:  # hold
                hold_score += weight * confidence
            
            total_confidence += confidence
            avg_price += signal.price * weight
            total_weight += weight
        
        # Determine combined signal type
        if buy_score > sell_score and buy_score > hold_score:
            signal_type = 'buy'
            confidence = buy_score
        elif sell_score > buy_score and sell_score > hold_score:
            signal_type = 'sell'
            confidence = sell_score
        else:
            signal_type = 'hold'
            confidence = hold_score
        
        # Generate reasoning
        reasoning = f"Combined signal from {len(timestamp_signals)} strategies: "
        reasoning += f"buy={buy_score:.2f}, sell={sell_score:.2f}, hold={hold_score:.2f}"
        
        return StrategySignal(
            timestamp=timestamp_signals[0][1].timestamp,
            signal_type=signal_type,
            confidence=confidence,
            price=avg_price / total_weight if total_weight > 0 else 0.0,
            strategy_name="hybrid",
            parameters={'weights': weights},
            reasoning=reasoning
        )
    
    def _calculate_combined_performance(self, individual_results: Dict[str, StrategyResult], 
                                      weights: Dict[str, float]) -> Dict[str, float]:
        """
        Calculate combined performance metrics.
        
        Args:
            individual_results: Individual strategy results
            weights: Strategy weights
            
        Returns:
            Dict: Combined performance metrics
        """
        combined_metrics = {}
        
        # Weighted average of individual metrics
        for metric in ['win_rate', 'avg_return', 'total_return', 'profit_factor']:
            weighted_sum = 0.0
            total_weight = 0.0
            
            for strategy_name, result in individual_results.items():
                weight = weights.get(strategy_name, 1.0 / len(individual_results))
                metric_value = result.performance_metrics.get(metric, 0.0)
                weighted_sum += metric_value * weight
                total_weight += weight
            
            combined_metrics[metric] = weighted_sum / total_weight if total_weight > 0 else 0.0
        
        # Sum of total signals and trades
        combined_metrics['total_signals'] = sum(r.performance_metrics.get('total_signals', 0) for r in individual_results.values())
        combined_metrics['total_trades'] = sum(r.performance_metrics.get('total_trades', 0) for r in individual_results.values())
        
        return combined_metrics
    
    def _calculate_combined_risk(self, individual_results: Dict[str, StrategyResult], 
                               weights: Dict[str, float]) -> Dict[str, float]:
        """
        Calculate combined risk metrics.
        
        Args:
            individual_results: Individual strategy results
            weights: Strategy weights
            
        Returns:
            Dict: Combined risk metrics
        """
        combined_metrics = {}
        
        # Weighted average of individual risk metrics
        for metric in ['volatility', 'max_drawdown', 'sharpe_ratio', 'var_95']:
            weighted_sum = 0.0
            total_weight = 0.0
            
            for strategy_name, result in individual_results.items():
                weight = weights.get(strategy_name, 1.0 / len(individual_results))
                metric_value = result.risk_metrics.get(metric, 0.0)
                weighted_sum += metric_value * weight
                total_weight += weight
            
            combined_metrics[metric] = weighted_sum / total_weight if total_weight > 0 else 0.0
        
        return combined_metrics
    
    def get_available_strategies(self) -> List[StrategyType]:
        """
        Get list of available strategies.
        
        Returns:
            List[StrategyType]: Available strategy types
        """
        return list(self.strategies.keys())

def get_strategy_engine(config: Optional[Dict[str, Any]] = None) -> StrategyEngine:
    """
    Get a strategy engine instance.
    
    Args:
        config: Configuration dictionary
        
    Returns:
        StrategyEngine: Configured strategy engine
    """
    return StrategyEngine(config) 